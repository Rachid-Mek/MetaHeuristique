package partition.exactSol;

import java.util.*;
import java.util.function.Function;
import java.time.Duration;
import java.time.Instant;

class CustomSearch extends GraphSearch<List<Integer>> {
    Set<String> visited = new HashSet<String>();

    CustomSearch(Function<Vertex<List<Integer>>, Void> func) {
        super(func);
    }

    @Override
    boolean isVertexVisited(Vertex<List<Integer>> v) {
        return visited.contains(v.value.toString());
    }

    @Override
    void setVertexVisited(Vertex<List<Integer>> v) {
        visited.add(v.value.toString());
    }
}

class SolutionDetails {
    int difference;
    int numOfSols;
    int set;
    List<List<List<Integer>>> partittions;
    // excution time
    Duration excutionTime;

    public SolutionDetails(List<List<List<Integer>>> partitions, int[] set) {
    };
}

public class PartitionSet {
    /**
     * Find all partitions of a set of integers that minimize the difference between
     * the sum of the two partitions
     * Since the the two partitions S1 and S2 add up to the sum of the set S,
     * the difference between the sum of the two partitions is equal to
     * |S1 - S2| = |(S - S1) - S1| = |S - 2*S1|
     * So the problem is to find the partition S1 that minimizes |S - 2*S1|
     * The solution uses a graph search algorithm to find the partition S1 where
     * each node in the graph is one of the two partitions i.e S1
     * The graph is constructed by adding a node for each possible partition S1
     */

    List<Integer> set;
    private int sum;
    private List<List<Integer>> bestSolutionsFirstPartition;
    int bestDifference;
    int numOfVisitedNodes = 0;
    int numOfVisitedNodesBeforeSolution;
    Duration excutionTime;

    PartitionSet(int[] set) {
        this.set = new ArrayList<Integer>();
        sum = 0;
        for (int i : set) {
            this.set.add(i);
            sum += i;
        }
        bestSolutionsFirstPartition = new ArrayList<List<Integer>>();
    }

    /**
     * Add neighbors to a given vertex
     * The value of each neighbor is generated by adding one element to the value of
     * the vertex from the set of non-used elements
     *
     * @param v
     */
    private void addNeighbors(Vertex<List<Integer>> v) {
        List<Integer> nonUsedElements = setsDifference(set, v.value);
        for (int i : nonUsedElements) {
            List<Integer> list = new ArrayList<Integer>(v.value);

            list.add(i);
            list.sort((a, b) -> {
                return a > b ? a : b;
            });
            Vertex<List<Integer>> newVertex = new Vertex<List<Integer>>(list);
            v.addNeighbor(newVertex);
        }
    }

    public List<List<List<Integer>>> solve() {
        // initial state is an empty set
        Vertex<List<Integer>> initialState = new Vertex<List<Integer>>(new ArrayList<Integer>());
        bestDifference = calcDifference(initialState.value);
        GraphSearch<List<Integer>> search = new CustomSearch(v -> {
            numOfVisitedNodes++;
            addNeighbors(v);
            return evaluateSolution(v);
        });

        Instant startTime = Instant.now();
        search.dfs(initialState);
        this.excutionTime = Duration.between(startTime, Instant.now());
        // list of pairs of partitions that minimize the difference
        List<List<List<Integer>>> solutions = new ArrayList<List<List<Integer>>>();
        for (List<Integer> set1 : bestSolutionsFirstPartition) {
            List<List<Integer>> pair = new ArrayList<List<Integer>>() {
                {
                    add(set1);
                    add(setsDifference(set, set1));
                }
            };
            solutions.add(pair);
        }

        return solutions;
    }

    /**
     * Evaluate the solution and update the best solutions list
     *
     * @param v
     * @return
     */
    private Void evaluateSolution(Vertex<List<Integer>> v) {
        int newDifference = calcDifference(v.value);
        if (newDifference < bestDifference) {
            // update the best solutions list
            bestSolutionsFirstPartition = new ArrayList<List<Integer>>();
            bestSolutionsFirstPartition.add(v.value);
            bestDifference = newDifference;
            numOfVisitedNodesBeforeSolution = numOfVisitedNodes;
        } else if (newDifference == bestDifference) {
            // add the solution to the list of best solutions
            bestSolutionsFirstPartition.add(v.value);
        }
        return null;
    }

    /**
     * Calculate the absolute difference between the two partitions, given one
     * partition
     *
     * @param partition
     * @return
     */
    private int calcDifference(List<Integer> partition) {
        // calculate the difference between the two sets, given one set
        int partitionSum = partition.stream().mapToInt(Integer::intValue).sum();
        return Math.abs(sum - 2 * partitionSum);
    }

    /**
     * Calculate the difference between two sets
     *
     * @param set1
     * @param set2
     * @return
     */
    private List<Integer> setsDifference(List<Integer> set1, List<Integer> set2) {
        List<Integer> difference = new ArrayList<Integer>(set1);
        for (int i = 0; i < set2.size(); i++) {
            difference.remove(set2.get(i));
        }
        return difference;
    }
}
